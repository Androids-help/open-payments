---
id: flow
title: Basic Flow
---

import { PersonToPerson } from './personToPerson'
import { RequestToPay } from './requestToPay'

Once the client has discovered the URL of the account at the server, they use
the APIs on the server to setup and complete the payment. The specific APIs that
are used and the order they are accessed will differ based on the
[use case](./p2p) however the general flow is described here.

## Creating Invoices vs Paying into Accounts

Interledger payments are always sent using the
[STREAM protocol](./terminology#stream) which requires that the sender has
connection credentials to begin sending the payment. The purpose of the setup is
to exchange the details required to finalise the terms of the payment and
ultimately for the sender to get the connection credentials it requires to make
the payment.

The majority of payments are made toward an invoice and the outcome of the setup
is creation of an [invoice](./invoices) at the receiver, following which, the
sender will get [connection credentials](./connections) linked to that invoice.

The exception to this are use cases that have no discreet payment amount such as
[web monetization](./web-monetization). In this case the connection credentials
will be linked to the receiver's [account](./accounts) and not a specific
invoice.

Irrespective of whether the sender is paying an invoice or paying into an
account, they will have a URL representing the resource and will get the
connection credentials relative to that URL using the same
[connections API](./connections).

## Sending Money

To send a specific amount of money the sender creates an invoice via the
[invoice API](./invoices) at the receiver.

The sender then uses the URL of the invoice to get the connection credentials as
defined in the [connections API](./connections).

For use cases such as Web Monetization, with no fixed amount, no invoice is
created and the URL of the **receiving account** is used to get a
[connection](./connections) instead.

Using the credentials it receives, the sender opens a STREAM connection and
starts sending payments until the invoice is paid, the amount sent exceeds a
maximum set by the sender, or the sender chooses to stop sending (e.g. moves
away from a Web page it was paying via Web Monetization).

An example using the
[javascript STREAM client](https://github.com/interledgerjs/ilp-protocol-stream)
is shown below.

```javascript
const connection = await createConnection({
  plugin: getPlugin(),
  destinationAccount,
  sharedSecret,
})

const stream = connection.createStream()
await stream.sendTotal(200)
stream.end()
```

The sending wallet should debit the senders account before performing the
payment and should the payment fail or only partially succeed, the wallet must
credit the unsent balance back to the senders account.

## Receiving Money

In order to receive money over Open Payments, an invoice resource is created at
the receiving wallet and the URL of the invoice is presented to the sender.

If the payment has been pre-authorized then the invoice is submitted as part of
a [charge](./charges) against an authorized [mandate](./mandates).

Receiving wallets must:

1. Ensure the STREAM connection credentials they provide to clients can be
   mapped back to the invoice when the incoming connection is established
2. Credit the **paid** balance of the invoice for any incoming payments on any
   connections that are mapped to that invoice

### 1. Mapping the connection to the invoice with ILP and STREAM

[STREAM](./terminology#stream) provides a mechanism for encoding data into an
ILP address (shown as `destinationAccount` below) using a **Connection Tag**.
This allows the receiving wallet to encode data into the address that can then
be decoded when accepting an incoming connection.

The following shows an example of encoding data into the credentials provided to
the sender.

```javascript
const { encodeData } = require('encoder')
const connectionTag = encodeData(invoiceId)
const { destinationAccount, sharedSecret } = server.generateAddressAndSecret(
  connectionTag
)
```

The receiving wallet can now decode the data when it receives an incoming STREAM
and knows which invoice to allocate any payments received.

### 2. Accounting for an incoming Payment

As shown above, the receiving wallet can use the encoded invoice data to
determine which invoice to credit for incoming STREAM payments.

The following shows example code of what the wallet would do:

```javascript
const { createServer } = require('ilp-protocol-stream')
const { decodeData } = require('encoder')
const { creditInvoice } = require('invoice')

const streamServer = await createServer({
  plugin: getPlugin(),
})

streamServer.on('connection', (connection) => {
  // Determine who this connection belongs to by correlating with connectionTag
  const connectionTag = connection.connectionTag

  // Get the invoiceId from the connectionTag
  const invoiceId = decodeData(connectionTag)

  connection.on('stream', (stream) => {
    //Set how much you want to allow for this STREAM.
    stream.setReceiveMax(10000000000000)

    stream.on('money', (amount) => {
      // Credit the invoice for the amount received
      creditInvoice(invoiceId, amount)
    })
  })
})
```
